[{"type":"file","name":"html转图片或PDF.md","title":"html转图片或PDF","timestamp":1520229343000,"date":"2018-03-05 13:55:43","tags":"node,pdf","content":"\n\n今天带来一个好玩的网页截图功能 ，就是将网页转换成一张图片 或者 PDF\n\n<!-- more -->\n刚开始发现网上有很多 方案 ，例如 ： http://blog.csdn.net/younglao/article/details/77746039\n\n这里介绍了三种：\n\n- html-pdf 模块\n- wkhtmltopdf 工具\n- phantom 模块\n\n这三种方法各有优缺点，视情况选择。\n\n其中我用过 phantom ，所以我就试着用它来实现该功能 。\n\n实现的代码还是挺少的 ，我使用了 express 做一个服务端， 通过调用接口 /html2img 来将 指定的网址 ： https://www.baidu.com/ 转成了 pdf ，效果如图：\n\n![html2pdf](/images/html2pdf.png)\n\n\n代码如下：\n\n```js\n// html 转为 pdf 或者 图片\nrouter.get('/html2img', async function(req, res, next) {\n\n     var url = \"https://www.baidu.com/\";\n     var path = \"./public/snapshot/shot.pdf\"; // 将后缀名改为 png 即可保存为图片\n     var ph = await phantom.create();\n     var page = await ph.createPage();\n     var status = await page.open(url);\n     page.property('viewportSize',{width: 1000, height: 500}); //设置视窗的大小\n     await page.render(path)\n     console.log('Page rendered');\n     ph.exit();\n     res.sendfile(path);\n\n});\n\n```\n\n上面网址给出的例子 使用大量的回调函数，代码看起来极为负责 ，这里我使用 `async` 和 `await` 将代码简化，更加清晰，便于理解。\n\npage.render() 生成文件之后，便可以使用 res.sendifle() 来发送文件或者使用 res.download() 在客户端唤起下载器 下载该pdf 。\n\n> end\n","categories":"未分类"},{"type":"file","name":"finally-goodbye.md","title":"finally goodbye!","timestamp":1519804738000,"date":"2018-02-28 15:58:58","tags":"私人","password":"ljy","content":"\n\n...\n<!-- more -->\n\n初恋，多么难忘，我可能会记你一辈子吧 ，或许等到我老年痴呆，都可能还会喊你的名字，到时候也不知道你还能不能打出喷嚏，哈哈\n\n分手后 ，我的想法就一直很乱 ，我不想去理顺了 ，let it be 吧， 就这样逐渐遗忘  不再想起 最好了\n\n所以 ，我说了那些话 ，为了保护你 ，也为了保护我自己 ， 到了现在这个时候 ，我们之间只有互相伤害了 ，\n\n我们的感情真的都回不去了。\n\n很可惜 ， 很遗憾 ，每每想起你 ，内心都是悲伤\n\n彻底放手，固然痛苦 ，但也是最好的选择 ，\n\n再见了，我的爱人 ，小奶猫\n\n你好呀，我的朋友 ， 李金妍\n\n![goodbye](/images/goodbye.jpeg)\n","categories":"未分类"},{"type":"file","name":"输入提示防抖处理.md","title":"输入提示防抖处理","timestamp":1519536485000,"date":"2018-02-25 13:28:05","tags":"js,debounce,防抖","content":"\n\n经常会有输入提示这种需求 ， 输入一个字符 提示出相应的可能提示搜索词，这种需求也很普遍了。\n\n但是没输入一个字符 就要发送一次请求，那是很浪费服务器资源的，稍加处理就可以避免了。\n\n<!-- more -->\n\n防抖处理 ， 也叫 debounce ， 在underscore.js中就有这样一个[debounce函数](https://segmentfault.com/a/1190000002764479)，下面将实现一个简单的防抖函数：\n\n```js\nvar timer = null;\nfunction debounce(){\n  console.log(\"start\")\n  clearTimeout(timer);\n  timer = setTimeout(function(){\n      console.log('发送请求，获取数据并且展示')\n  },500);\n}\n```\n\n类似的，为了限制某一段时间内发出请求的数量，在滚动浏览器页面时，可能滚动一次 调用了很多个函数，为了限制这种情况，在 underscore.js 中有一种叫函数节流的方式 throttle。\n\n\n### Lodash\n如果需要 debounce 和throttle 这两个方法，可以使用lodash来讲两个方法合成一个文件。\n\n![lodash](/images/lodash.png)\n\n可以压缩后的文件还是很小的。\n\n### 参考\n\nhttps://segmentfault.com/a/1190000002764479\nhttp://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/\n","categories":"未分类"},{"type":"file","name":"如何在vue-router中做路由权限控制.md","title":"如何在vue-router中做路由权限控制","timestamp":1519524992000,"date":"2018-02-25 10:16:32","tags":"vue,权限控制","content":"\n\n## vue-router的权限控制\n\n前几天重新对vue-router看了一遍，记录了一下大概的vue-router功能，如下：\n\n<!-- more -->\n\n- 动态路由\n- 嵌套路由\n- 访问路由\n- 路由name\n- 重定向\n- 别名 alia\n- 参数\n- 路由守卫\n- 过渡动画\n- 数据获取\n- 滚动行为\n- 懒加载\n\n今天来对于权限控制 （路由守卫） 来深入一下\n\n基本上所有对于权限控制的操作都可以在路由守卫中做。\n\n路由守卫 基于 router 的方法 beforeEach\n\n### 全局守卫\n\n下面就是一个简单的全局守卫的写法\n```js\nconst router = new VueRouter({ ... })\n\nrouter.beforeEach((to, from, next) => {\n  // ...\n})\n```\n\n> 如果有多个 全局守卫 ，则会按照声明顺序依次进行验证。\n\n每个守卫接收三个参数：\n\n- to: Route: 即将要进入的目标 路由对象\n\n- from: Route: 当前导航正要离开的路由\n\n- next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。\n\n> 确保要调用 next 方法，否则钩子就不会被 resolved。\n\n**全局后置钩子**\n你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：\n```js\n\nrouter.afterEach((to, from) => {\n  // ...\n})\n```\n\n### 独享守卫\n\n#### 路由独享\n\n是某一个路由 独有的守卫\n```js\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n```\nbeforeEnter 的参数和 beforeEach 的是一样的。\n\n\n#### 组件独享\n\n可以在路由组件内直接定义以下路由导航守卫：\n\n- beforeRouteEnter\n- beforeRouteUpdate (2.2 新增)\n- beforeRouteLeave\n\n```js\nconst Foo = {\n  template: `...`,\n  mounted(){},\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n    // 替代方法是 给next传一个回调\n    //\n    // beforeRouteEnter (to, from, next) {\n    //   next(vm => {\n    //     // 通过 `vm` 访问组件实例\n    //   })\n    // }\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用\n    // 可以访问组件实例 `this`\n  }\n}\n```\n\n## 例子\n\n\n```js\nrouter.beforeEach((to, from,next) => {\n\tlet isLogin = true;\n\tisLogin && limitRouterFunc({\n\t\tto,next,\n\t\tlimitPage:['/login','/register']\n\t})\n})\n\nlet limitRouterFunc = args => {\n\tconst { to,next,limitPage } = args;\n\tif( limitPage.indexOf(to.path)>=0 ){\n\t\tnext()\n\t} else {\n\t\tMessage({\n\t\t\ttype: \"warning\",\n\t\t\ttime: 1000,\t\t\t\t\t\n\t\t\tcontent: `请先登录~！`,\n\t\t\tnext:()=>{\n\t\t\t\tconsole.log('然后你要登录呢？');\n\t\t\t}\n\t\t})\n\t\tnext({path: limitPage[0]});\n\t}\n}\n\n```\n\n最后在强调，beforeEach 必须要调用next方法 next的参数可见 https://router.vuejs.org/zh-cn/advanced/navigation-guards.html\n","categories":"未分类"},{"type":"file","name":"新的一年，旧的烦恼，哈哈.md","title":"新的一年，旧的烦恼，哈哈","timestamp":1519349701000,"date":"2018-02-23 09:35:01","tags":"","content":"\n\n<!-- more  -->\n\n今天初八，开始上班了，十天的假期结束了，这些天在家里那叫一个舒服，为所欲为 哈哈。\n\n还是一如既往的，假期前的豪云壮志，假期中的无所事是。家真的是养肉的天堂，不过还好我没有胖，毕竟不能胖下去了。\n\n与以往不同的是，假期后没有后悔，没有觉得这个假期虚度了，虽然没做什么学习，没敲一行代码，但是和家人待在一起感觉很惬意，这也许要工作后才能体会到。\n\n新的一年，旧的烦恼，驾照、工作、身材......  去年的烦恼，还是要赶紧解决吧。\n\n千里之行始于足下。\n","categories":"未分类"},{"type":"file","name":"github的小徽章.md","title":"github的小徽章","timestamp":1518144404000,"date":"2018-02-09 10:46:44","tags":"github","content":"\n前几天折腾 github 的 readme 文档真的烦死了，好在昨天弄好了，今天写一下，记录一下坑。\n<!-- more -->\n先看看效果吧 ==> [戳这](https://github.com/LqqJohnny/VBlog)\n\n我一开始看到这个就会想这有什么难的  ，就用markdown语法引入几张图片而已嘛！\n\n事实并非如此，这里面的坑多着呢！\n\n### 图标来源\n\n有些图标是和项目实际情况同步的 ，例如 下载数量 、 build status ，\n\n<img src=\"https://camo.githubusercontent.com/514abce7f4f4e57ca8e353bccf57968572abe342/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f646d2f7675652e737667\">\n\n这个是真实的实时反映下载量的，所以肯定要和项目联系起来。还有build status：\n\n<img src=\"https://camo.githubusercontent.com/07ce5da29c49e8b5c6ef00d818d2c3d38c04fa55/68747470733a2f2f696d672e736869656c64732e696f2f636972636c6563692f70726f6a6563742f7675656a732f7675652f6465762e737667\">\n\n这些就要用到 [shields.io](http://shields.io/) 了,复杂一点的图标可能还会用到 [travis-ci](https://travis-ci.org/) 等工具\n\n下面是几篇 图标用法文章：\n\n- https://lpd-ios.github.io/2017/05/03/GitHub-Badge-Introduction/\n\n- https://www.liaoxuefeng.com/article/0014631488240837e3633d3d180476cb684ba7c10fda6f6000\n\ntravis 使用时需要注意的是 ：\n  - 必须要对应你的项目\n  - travis 配置文件必须要上传，且要注意传到的分支，使用时要带上分支名\n\n### 怎么使用\n\n使用的过程很是抓狂。\n\n如果用 `shields.io` 推荐的方法，\n```\n[![CocoaPods](https://img.shields.io/cocoapods/l/AFNetworking.svg)]()\n```\n可以引入 ，但是不能让他居中 为了让他居中，还需要加上html标签\n\n``` html\n<p align='center'>\n[![CocoaPods](https://img.shields.io/cocoapods/l/AFNetworking.svg)]()\n<!-- 如果是多个图标的话 中间不能用换行，否则markdown会解析为 p 标签破坏原有结构 导致强行换行 -->\n[![CocoaPods](https://img.shields.io/cocoapods/l/AFNetworking.svg)]()\n</p>\n```\n\n现在传上github试试看。。你可能会发现怎么没有图标变成了一串 文字， markdown的语法没有解析 这还是 html标签的问题。\n\n所以，涨了个姿势： md 如果用了 html标签 它里面就尽量不要写md 语法了，要写就也写 html 。\n\n换成下面这样 ：\n```html\n<p align=\"center\">\n  <a href=\"https://travis-ci.org/LqqJohnny/VBlog\"><img src=\"https://travis-ci.org/LqqJohnny/VBlog.svg?branch=develop\" alt=\"Build Status\"></a>\n  <a ><img src=\"https://img.shields.io/badge/language-javascript-yellow.svg\" alt=\"Build Status\"></a>\n</p>\n```\n\n这样在上传一下就 ok了。\n\n### 总结\n\n\n装逼是要付出代价的。\n","categories":"未分类"},{"type":"file","name":"搭建一个类HEXO博客框架.md","title":"搭建一个类hexo博客框架","timestamp":null,"date":"2018/2/1 上午9:50:32","tags":"hexo","categories":"hexo","content":"\r\n\r\n前段时间利用空闲时间，结合自己之前失败的经验以及一时的兴奋加上一丝幸运，成功的完成了一个博客框架。\r\n\r\n<!-- more -->\r\n\r\n## 搭建一个类hexo博客框架\r\n\r\n### 背景\r\n> 以下都是废话，请直接跳过\r\n\r\n其实在几个月前我就想要自己做一个博客网站了，看着别的大神都有自己的博客网站，甚是羡慕呀！ 那个时候自己用hexo + Git Page 做了一个博客站点，那也让我高兴了好几天。感觉有了自己的秘密小花园。 但是几天后 ，我就开始在想 ，hexo 生成静态网站的原理，在网上经过一番了解之后，想要自己做一个这样的工具。做自己的网站，那肯定会是一件很cool的事。于是，我自己从零开始自己尝试写一个 山寨hexo 。但是第一次尝试 ，以失败告终了。卡在了一个点： 怎么解析 md 文件并把相对应的信息用到 模板文件里去。尝试网上说的各种方法，最终放弃了。知道前段时间我看到一个项目，将数据存入一个json 在用的时候引入这个json。\r\n\r\n于是，之前的问题就有了一个解决方案了：\r\n\r\n### 思路\r\n\r\n- webpack 打包过程用fs 解析每一个md文件，取出文件头中的title ，type，路径 等信息，存入一个 `article.json`\r\n- 在模板文件（该项目选用的是vue，可以任意选用其他框架或者模板）中，直接require 那个文件，即可使用文章title展示博客列表\r\n- 根据路由参数 `articles/:id` 获取文章的标题 ，找到文章的路径，引入对应的 md 文档，并且webpack配置 `md-loader` ,即可展示某一篇博客的内容\r\n- 将一些网站的标题，主题等设置 ，分离到一个json配置文件。\r\n- 将视图模板 分离出来，置于 theme 中 ，便于以后博客主题的扩展。\r\n\r\n\r\n### 具体实现\r\n\r\n#### 获取md信息\r\n\r\n分别存为三个文件 ，articles.json   tags.json  categeries.json 分别用于 展示 博客列表页， 分类页面 和  标签页面 。\r\n\r\n```js\r\nfunction findSync(startPath) {\r\n    let ret = {\r\n      result: [],\r\n      tags : {},  //  用于 标签页\r\n      categories : {}  // 用于 分类页\r\n    }\r\n    var path = startPath;\r\n    let files=fs.readdirSync(path);\r\n    files.forEach((val,index) => {\r\n      console.log(\"正在打包 ：\"+val);\r\n        let fPath=join(path,val);\r\n        let stats=fs.statSync(fPath);\r\n        // if(stats.isDirectory()) {result.unshift({type:\"directory\",name:val,path:pa})};\r\n        if(stats.isFile()){\r\n          // 解析出 文章的参数 信息\r\n          var data=fs.readFileSync(fPath,\"utf-8\");\r\n          var headInfo = getHeader(data,fPath,val,ret.tags,ret.categories);\r\n\r\n          ret.result.push(Object.assign({},{type:\"file\", name:val},headInfo.headJSON));\r\n          ret.tags =  Object.assign({},ret.tags,headInfo.tags);\r\n          ret.categories =  Object.assign({},ret.categories,headInfo.cates);\r\n        }\r\n    });\r\n    return ret;\r\n}\r\n//  获取文章的 头部信息。\r\nfunction getHeader(data,path,filename,tags,cates){\r\n  var start = data.indexOf(\"---\");\r\n  var end = data.indexOf(\"---\",start+3);\r\n  if(start===-1 || end===-1 || start===end){ // 没有文字信息头\r\n    return {};\r\n  }\r\n\r\n  var mdHead = data.substring(start+3,end);\r\n\r\n  var headArr = mdHead.split(/\\n/).filter(function(val){\r\n      return val!==\"\"&&val!==\"\\r\";\r\n  });\r\n  var headJSON = {};\r\n  headArr.map(function(val){\r\n    var arr = val.split(\":\");\r\n    var key = arr[0];\r\n    if(key===\"date\"){\r\n      var val = arr.slice(1).join(\":\").replace(/\\r/g,\"\").trim();\r\n    }else{\r\n      var val = arr[1].replace(/\\r/g,\"\").replace(/\\[/g,\"\").replace(/\\]/g,\"\").trim();\r\n\r\n    }\r\n    if(key ===\"date\"){ headJSON[\"timestamp\"] = new Date(val).getTime();}// 将时间转为 long 有助于排序\r\n    if(key === \"categories\"){cates = Object.assign({},cates,addTagsOrCates(key,val,filename,cates)) }\r\n    if(key === \"tags\"){tags = Object.assign({},tags,addTagsOrCates(key,val,filename,tags))}\r\n\r\n    headJSON[key] = val;\r\n  })\r\n    return {headJSON,tags,cates};\r\n}\r\n\r\n```\r\n\r\n\r\n#### 列表页\r\n\r\n\r\n```js\r\n<template>\r\n···\r\n<div class=\"articlesList\">\r\n  <div class=\"article_item\" v-for=\"a in list\" >\r\n    <router-link :to=\"genUrl(a.name)\">{{genTitle(a.name)}}</router-link>\r\n    <span class=\"date\">{{getDate(a.timestamp)}}</span>\r\n  </div>\r\n</div>\r\n···\r\n</template>  \r\n<script>\r\nvar arts = require('../../../../articles.json');\r\nconst {site , passwordOn} = require(\"../../../../blog.config.js\");\r\nexport default {\r\n  data(){\r\n    return {\r\n      list:arts,\r\n    }\r\n  },\r\n  mounted(){\r\n      document.title= site.title ;\r\n  },\r\n  methods:{\r\n\r\n    genUrl(name){\r\n      return \"/article/\"+name.replace(/\\.md/g,'');\r\n    },\r\n    genTitle(name){\r\n      return name.replace(/\\.md/g,'');\r\n    },\r\n    getDate(time){\r\n      var date = new Date(time);\r\n      return date.getFullYear()+\" / \"+(date.getMonth()+1)+\" / \"+date.getDate();\r\n    }\r\n  }\r\n}\r\n</script>\r\n```\r\n\r\n#### 博客页\r\n\r\n\r\n```js\r\n<template lang=\"html\">\r\n<div class=\"articleInfo\">\r\n  <div class=\"title\">{{$route.params.id}}</div>\r\n  <hr>\r\n  <div class=\"info\">\r\n    <span v-if=\"date\">日期 :{{date}} </span>\r\n    <span v-if=\"tags\">标签 :{{tags}} </span>\r\n    <span v-if=\"categories\">分类 ： {{categories}} </span>\r\n  </div>\r\n  <div id=\"artConWrap\">\r\n      <article class=\"article\" id=\"article\" v-html=\"articleContent\" v-highlight >\r\n      </article>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nvar articles = require('../../../../articles.json');\r\nexport default {\r\n  data(){\r\n    return {\r\n      articleContent: \"\",\r\n      date:\"\",\r\n      tags:\"\",\r\n      categories:\"\",\r\n    }\r\n  },\r\n\r\n  beforeMount(){\r\n    var id = this.$route.params.id;\r\n    var _this = this;\r\n    articles.map(function(val){\r\n      if(val.title.trim() === id){\r\n        _this.date = val.date ;\r\n        _this.tags = val.tags ;\r\n        _this.categories = val.categories ;\r\n        _this.password=val.password;\r\n      }\r\n    })\r\n  },\r\n  mounted(){\r\n\r\n    var id = this.$route.params.id;\r\n\r\n    document.title= id;  //  设置标题\r\n\r\n    var md = require('../../../../articles/'+id+'.md');\r\n    var start = md.indexOf('<!-- deleteAbove -->');\r\n    if(start>0){\r\n      md = md.substring(start+\"<!-- deleteAbove -->\".length);\r\n    }\r\n    this.articleContent = md;\r\n  }\r\n}\r\n</script>\r\n\r\n```\r\n\r\n#### 项目结构优化\r\n\r\n现在文章能展示了 ，剩下的就是结构的优化了，参考了hexo的结构，将一些东西给提取到配置文件，具体的介绍可查看(项目介绍)[https://github.com/LqqJohnny/VBlog].\r\n\r\n\r\n### 总结\r\n\r\n自己撸一个博客出来，那股成就感还是很大的，对自己也更有信心了，再一次感觉到vue的魅力，一天就能做出一套博客主题来了。这开发效率真的高。之后还会基于这个项目的结构，做一个 类gitbook的项目 ，在这个基础上，应该能很快的开发完，相当于换一个展示主题而已。\r\n"},{"type":"file","name":"压缩js和css的命令行工具.md","title":"压缩js和css的命令行工具","timestamp":1517814171000,"date":"2018-02-05 15:02:51","tags":"js","content":"\n\n这是一个压缩代码的小工具，js 和 css 都可以压缩 且可批量压缩 执行 `ug src dest` 就可以将src里面的所有js 和css 压缩到 文件夹 dest。\n\n<!-- more  -->\n\n## 源码\n该工具的源码在 [这里](https://github.com/LqqJohnny/uglify-tool)\n\n## 使用\n```bash\n#全局安装\nnpm install uglify-tool -g\n# 批量压缩\nug src dest\n#单个压缩\nug main.css target.css\n#单个压缩\nug main.css dest/main.css\n\n```\n## 优缺点\n优点： 使用方便，可多文件压缩，也可单文件压缩 ，也可多层次压缩\n缺点： 代码粗糙，错误提示不完整\n\n## 原理\n1. 根据命令行输入的 第2和第3个参数 ，确定输入和输出，在判断输入输出的路径是 文件 还是文件夹，在做出不同的处理\n2. 如果是 文件 ，直接压缩。\n3. 如果是文件夹，则遍历文件夹下的文件 ，逐个压缩，碰到文件加 则用递归重复以上步骤。\n\n## 总结\n在日常开发中，如果不是使用webpack，grunt等可自动化的工具的时候，想要去压缩你的js和css文件 试衣间比较麻烦的事，例如一些古老的 jq 项目，javaweb项目。\n\n这时，你可能需要新建一个grunt 或者 webpack ，再安装依赖什么的 ，这就很麻烦了，还会给项目里面加上一些不必要的文件 如： node_modules package.json webpack.conf.js ......\n\n而这个工具就可以解决上面的麻烦，简单一句 cmd 即可。\n","categories":"未分类"},{"type":"file","name":"hexo展示其他项目example.md","title":"hexo展示其他项目example","timestamp":1517476366000,"date":"2018-02-01 17:12:46","tags":"hexo","categories":"hexo","content":"\n用过hexo的人可能会发现，在`github`上使用`gitpage`之后,其他项目就无法使用`gitpage`了，因为`github`限制了每个人智能开一个`gitpage`，但是水来土掩，换个方式，就可以解决这个问题了。\n\n<!-- more -->\n\n\n> 本文水分比较多 ，懒得看的，直接看最后总结找解决方法\n\n\n### 更简单的方法？\n\n其实有很多方法 ，比如再创建一个账号 ，一个专门用来展示 demo的页面，或者利用其它网站 codepen 码云 ... 等网站来展示demo，\n\n但，这里分享一个更简单的方法 。\n\n### 探究过程\n首先 ，接受只能有一个gitpage的事实 ,gitpage是怎么实现的呢 ，稍微看下hexo上传之后的目录  你会发现 `XXXX.github.io` 对应的就是你的hexo项目上传的代码里面的`index.html`\n\n那如果我把 我的demo 放在他的目录里面一起传上去例如 ： `/demo/index.html` 这样不就可以了吗？\n\n来 尝试一下\n\n把文件夹复制进`.deploy_git`文件夹  ，再 `hexo g -d` , 等待\n\n**失败**\n打开 `.deploy_git` 一看，刚才复制进去的文件夹不见了 ，回头看看 `hexo d` 执行的结果 ，第一句就是 clear .deploy_git 也就是每次deploy 都会把里面内容都删除 重新打包，所以我们刚加的文件夹被删了。\n\n有什么办法呢 ，再看看   `hexo d` 的执行输出语句，还有一句\n\n`Copying files from public folder...`\n\n对了 就是这句，把demo放进public文件夹试试？\n\n- `/demo/indx.html`复制进public\n- hexo d\n\n查看 `.deploy_git` demo文件夹有了\n在打开网址  `XXXX.github.io/demo/index.html` 看看  \n**成功**\n\n\n### 总结\n放在public文件夹里面的文件不会被删除，会原样的上传至github，通过对应的路径即可访问自己的静态html文件。\n```\n--public\n    |___ demo   // 加入此文件夹\n          |___ index.html\n\n\n访问地址 : https://你的名字.github.io/demo\n```\n"},{"type":"file","name":"知乎复制粘贴自带版权信息的js代码.md","layout":"blog","title":"知乎复制粘贴自带版权信息的js代码","timestamp":1516589531000,"date":"2018-01-22 10:52:11","tags":"js","content":"\n\n\n在知乎、简书、segmentfault等网站上面复制文字如果超过一定长度的话户，在粘贴的时候会发现后面跟着一串版权信息声明。\n虽然有的时候比较烦人，但是这对于促进大家重视知识版权有很大帮助，也有利于网站的推广。\n<!-- more -->\n要是我的博客上也能加上这么一段就好了。于是，在网上查实现的原理 ，发现就是监控了全局的复制（copy）事件，只需要对你想要监控的区域，添加事件监控，在事件处理里面加上自己定制的版权信息就ok了。\n\n代码如下：\n\n```js\nfunction setClipboardText(event){\n            event.preventDefault();\n            var node = document.createElement('div');\n            //对documentfragment不熟，不知道怎么获取里面的内容，用了一个比较笨的方式\n            node.appendChild(window.getSelection().getRangeAt(0).cloneContents());\n            var htmlData = '<div>著作权归作者所有。<br />'\n                            + '商业转载请联系作者获得授权，非商业转载请注明出处。<br />'\n                            + '作者：lqq<br />链接：http://lqq.XXXXX<br />'\n                            + '来源： XXXX<br /><br />'\n                            + node.innerHTML\n                            + '</div>';\n            var textData = '著作权归作者所有。\\n'\n                            + '商业转载请联系作者获得授权，非商业转载请注明出处。\\n'\n                            + '作者：lqq\\n链接：http://lqq.XXXXX\\n'\n                            + '来源： XXXX\\n\\n'\n                            + window.getSelection().getRangeAt(0);\n            if(event.clipboardData){  \n                event.clipboardData.setData(\"text/html\", htmlData);\n                event.clipboardData.setData(\"text/plain\",textData);\n            }\n            else if(window.clipboardData){  \n                return window.clipboardData.setData(\"text\", textData);  \n            }  \n        };  \n        var answer = document.getElementById(\"answer\");\n        answer.addEventListener('copy',function(e){\n            setClipboardText(e);\n        });\n```\n","categories":"未分类"},{"type":"file","name":"密码是lqq.md","title":"密码是lqq","timestamp":1515727312000,"date":"2018/1/12 11:21:52","tags":"hello,webpack","categories":"hello","password":"lqq","content":"\r\n加密博客 ，可在md头部设定 ，如：\r\n```yml\r\ntitle: 密码是lqq\r\ndate: 2018/1/12 11:21:52\r\ntags: [hello,webpack]\r\ncategories: hello\r\npassword: lqq\r\n\r\n```\r\n密码输入错误将自动返回首页。\r\n"},{"type":"file","name":"hexo设置canvas背景.md","title":"hexo设置canvas背景","timestamp":1510542706000,"date":"2017-11-13 11:11:46","tags":"hexo","categories":"hexo","content":"\n<!-- deleteAbove -->\n### hexo 设置canvas背景\n\n使用hexo 都会需要使用一个主题 theme ，不同的主题可能会内置不同的背景图片，\n以 NEXT 主题为例，相信其他的主题的背景 设置应该是一样的。\n\n<!-- more -->\n\n#### NEXT 自带背景\n\n在主题文件夹 hexo-theme-next  里面 有一个_config.yml 配置文件 在这里面 搜索 canvas_nest  可以看到下面 后面设置的是 false ，下面还有 好几个一样的设置，这些都是 NEXT 已有的背景，可以改为 true 来设置想要的背景 动画。\n\n\n#### 定制背景动画\n\n1. 紧接上面，在 _config.yml 文件 另加一个配置，例如：\n```\ncolor-ribbon: true\n```\n2. 在  source/lib 里面 添加一个文件夹以及对应的画canvas背景的js， 例如 color-ribbon/color-ribbon.js\n\n3. 在layout/_scripts/vendors.swig 里面搜 canvas_nest，然后把那一段 if 复制 一份 改成 color-ribbon\n\n```js\n{% if theme.color_ribbon %}\n  {% set js_vendors.color_ribbon  = 'color-ribbon/color-ribbon.js' %}\n{% endif %}\n```\n然后 就可以在页面上看到效果了。\n\n\n**注意**：\n\n> 创建 canvas 元素，添加css样式并添加入body的操作尽量用js，不然还需要修改 公共样式和common.swig 比较繁琐，也容易产生冲突。\n\n> 最后提供一些 canvas背景素材 ， 需要自己审查代码，找到其中的js文件  [canvas背景素材](http://www.jq22.com/)\n"},{"type":"file","name":"使用说明.md","title":"使用说明","timestamp":1510012800000,"date":"2017-11-07","tags":"vblog,说明书","categories":"说明","content":"\r\n\r\n## VBlog\r\n\r\n![vblog](../static/vblog.png)\r\n\r\n\r\n### 简介\r\nVBlog 是我个人开发的博客框架，受启发于hexo 和 vue ，使用了vue-cli 的 webpack 配置代码 ，部分原理模仿 hexo 。也有许多与hexo 不同之处。\r\n\r\n项目地址：https://github.com/LqqJohnny/VBlog\r\n\r\n### 安装\r\n以下提供两种方式：\r\n\r\n- 方式 1： git clone\r\n\r\n``` bash\r\n# clone this project\r\ngit clone https://github.com/LqqJohnny/VBlog.git\r\n\r\n# then install dependencies\r\ncd VBlog  && npm install\r\n\r\n# serve with hot reload at localhost:8000\r\nnpm run dev\r\n```\r\n\r\n- 方式 2 ( 推荐 )： vblog-cli\r\n\r\n```bash\r\n# install vblog-cli :  https://github.com/LqqJohnny/vblog-cli\r\nnpm install -g vblog-cli\r\n\r\n# init your blogProject\r\nvblog init myBlog\r\n\r\n# then install dependencies\r\ncd VBlog  && npm install\r\n\r\n# serve with hot reload at localhost:8000\r\nnpm run dev\r\n\r\n```\r\n\r\n> 推荐使用方式2 ，vblog还有添加博客、删除博客和添加主题等指令，十分方便日后对于博客的使用。\r\n\r\n> 更多vblog-cli的指令请查看 [vblog-cli](https://github.com/LqqJohnny/vblog-cli)\r\n\r\n\r\n### 项目目录\r\n\r\n本项目目录演化自 `vue` 的 `webpack`配置 。\r\n\r\n\r\n```\r\n|───articles   博客原文件 md\r\n|───res   博客原文件中引用的资源(图片...)\r\n|   └───recycleBin  文章回收站\r\n├───build    webpack 文件\r\n├───config   配置文件\r\n├───dist     打包之后的静态页面\r\n│   └───static\r\n│       ├───css\r\n│       └───js\r\n|   └───index.html   可直接访问 index.html 看到  \r\n├───theme    主题模板文件  （默认主题、安装的新主题）\r\n│   └───default   默认主题\r\n│       ├───components  博客主题模板\r\n│       │   ├───common  通用组件\r\n│       │   └───pages   页面（首页，文章页...）\r\n│       └───router      路由管理\r\n└───static          静态资源\r\n└───articles.json   webpack 自动生成的关于文章的信息文件\r\n└───blog.config.js  网站的配置文件，可设置网站名字 作者等信息\r\n```\r\n\r\n### 运行项目\r\n\r\n\r\n`npm run dev` 可实时编辑文章，查看结果\r\n\r\n`npm run build` 可进行打包，生成静态文件 ，再上传到github 并设置gitPage，或者上传到自己的服务器，即可看到博客。\r\n\r\n\r\n### 编辑文章\r\n\r\n编辑文章，请在 `src/articles` 里进行\r\n\r\n在文章的开头，请务必 加上文件信息头，如下：\r\n```\r\n---\r\ntitle: 文章的标题\r\ndate: 时间（例如：2017-11-07 10:57:49  可以在编辑器上安装插入时间戳的插件）\r\ntags: [tag1,tag2]\r\n---\r\n```\r\n编写完成之后，在打包过程中，webpack 会在上述的文章信息头后加上一个标识\r\n`<!-- deleteAbove -->`\r\n用于在渲染页面时 不显示信息头。\r\n所以，在看到这一段 注释 的时候不要删除，并不会影响文章效果。\r\n\r\n### 配置网站信息\r\n\r\n在根目录下的 `blog.config.js` 中可以设置网站的信息，如：\r\n```js\r\nsite:{\r\n  title: 199,\r\n  subtitle: '面试造火箭，上岗拧螺丝',\r\n  description: ' --- 它在我的机器上可以很好运行！',\r\n  author: 'lqq',\r\n  email:'*****@qq.com'\r\n},\r\nfooter:{\r\n  url:\"https://github.com/LqqJohnny/SimpleBlogByVue\",\r\n}\r\n```\r\n暂时只加了这些信息 ，也可根据需要自行添加信息，并在components里面编辑模板，添加到想展现信息的地方。\r\n\r\n### 代码高亮\r\n 代码高亮使用的是 highlight.js 使用的颜色主题是 `gruvbox-light` 如果想修改请在 `blog.config.js` 中修改 highlightTheme ，可选的值可在highlight 官网查看,注意主题不再使用驼峰法。\r\n\r\n### 博客插入图片\r\n\r\n在博客中经常需要加入图片 ，把图片放入 static 静态文件夹中 在博客中直接以相对路径引入，如：\r\n`![图片](../../static/cat.jpg)` 。 具体的路径视情况而定。\r\n\r\n### 博客主题\r\n\r\n主题文件夹 `theme` 每个文件夹对应一个主题，要修改主题可在 blog.config.js 中修改`blogTheme`字段的值为对应文件夹的名称，重启服务器或者重新打包，即可看到主题更换。\r\n\r\n### 博客加密\r\n\r\n在 `blog.config.js` 中可以设置  `passwordOn: true` 来启动加密博客的功能，启动之后 只需要在待加密博客的头部设置 `password: 123` 即可加密。\r\n\r\n### 博客菜单\r\n\r\n在 `blog.config.js` 中的 menu 可以设置博客的菜单：\r\n```\r\nmenu:{\r\n  home:{name:'首页',href:'/'},\r\n  tags:{name:'标签',href:'/tags'},\r\n  categories:{name:'类别',href:'/categories'},\r\n}\r\n```\r\n\r\n## 总结\r\n 项目还在持续完善中，欢迎各位提出宝贵的建议！\r\n"},{"type":"file","name":"2017年10月书单.md","title":"2017年10月书单","timestamp":1509087413000,"date":"2017-10-27 14:56:53","tags":"书单","categories":"reading","password":"lqq","content":"\r\n<!-- deleteAbove -->\r\n我想开始把自己看的一些书记录下来了，没有每周必看几本书的目标，也没有看书必写感悟的决心。\r\n\r\n只是一个程序员工作之余的读书随笔。\r\n\r\n书 ，不限种类，不限字数，一切从心（怂。。。哈哈）\r\n<!-- more -->\r\n\r\n\r\n### 10 月 书 单\r\n\r\n#### 《围城》\r\n\r\n\r\n\r\n> 人生是围城，婚姻是围城，进去了，就被生存的种种烦愁包围。城里的人想出来，城外的人想进去。\r\n\r\n> 爱情与性欲一胞双生，类而不同，性欲并非爱情的基本，爱情也不是性欲的升华。\r\n\r\n> 旅行是最劳顿，最麻烦，叫人本相毕现的时候。经过长期艰苦旅行而不彼此讨厌的人，才可以结交朋友\r\n\r\n> 我们一生对于最亲爱的人的想念，加起来恐怕不到一点钟，此外不过是念头在他身上瞥过，想到而已。\r\n\r\n> 从前愚民政策是不许人民受教育，现代愚民政策是只许热敏受某一种教育。\r\n\r\n\r\n\r\n其实对于很多未知事物，人都很向往，不止婚姻。没有得到之前，它看上去是多么的美好，但是得到之后，接触之后，也就发现了其中令人抗拒的糟粕。当你是在忍受不了了，就想逃离。\r\n\r\n婚姻 ， 爱情 ，性这三者又有什么必然的联系吗？\r\n\r\n<!-- 看完这本书，对于这三者也有了一点思考。我现在是有点抗拒婚姻的，是因为看了书中的例子，我怕了？ 不 ，应该是对于婚姻没有那么憧憬了吧。初恋结束后，对于结婚已经失去了那股傻劲了。如果可以的话 ，我会尽量晚点结婚，这么年轻的时候，不想被家庭压着，才刚从大学出来，开始自己的独立生活，实在不想再回到那种状态。 就这样开心的享受一下，单身 或者 恋爱 不好吗？ 书中的男主角（方）也是这样想的吧，所以在回国的船上，即便知道她是有夫之妇，也知道她是在诱惑他，即使知道船一到，他们就要分别，他也愿意享受这段短暂的恋爱，或者叫暧昧。之后，又陷入了苏文纨和唐晓芙的三角恋。这时候的方还是选择爱情--唐晓芙，而不是家世显赫、海龟留学生的女神同学--苏文纨。虽然，之后被苏使计拆散而分手，苏的心里还是忘不了唐。因此，之后他不敢再爱了，他的婚姻也是 再一句气话中 决定了。这样的婚姻 自然是不会幸福的。后面的故事就全是一些鸡毛蒜皮的斗嘴，婚姻生活也没有丝毫的甜蜜可言。 -->\r\n\r\n<!-- 但是\r\n\r\n人不能被爱情打败。不能因为一次的失败，而把内心藏起来，这是懦弱。\r\n\r\nloving can hurt sometimes,but loving can mend your soul.\r\n\r\n我对于爱情还是很向往的 ， 初恋的时候不懂事，但是以后的恋情都能好好珍惜，不求终老，但求无悔。婚姻？滚你妈的，老子还没‘玩’够 ，我才不想进‘坟墓’呢！ -->\r\n\r\n\r\n#### 《解忧杂货铺》\r\n\r\n东野圭吾，善于推理文学的作家，对于在书中给你一些意想不到的剧情极其擅长，在书中也会偶尔埋下一些伏笔，整本书刚开始看，觉得就只是讲个故事，知道看完，才将所有的故事联系在一起，整本书没有什么华丽辞藻，就是一些很平淡的话 在讲一个 不平凡的故事（这也是多亏了翻译做的好），最后面的几章逐渐的将故事线连接起来。让我想起了去年看的异步电视剧《西部世界》，那种最后一集的酣畅淋漓实在刺激。\r\n\r\n书中的每个小故事，其实都能引发读者的思考，每个故事中的烦恼其实都是读者们的烦恼。 爱情与梦想，梦想与现实..... 或多或少的会引发共鸣。\r\n\r\n下面是我记录的一些句子：\r\n> 心，一旦离开了，就再不会回来。\r\n\r\n> 其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运 还是自己一步步走出来的。\r\n\r\n> 其实很久以前我就知道自己应该怎样选择，只是一直无法下决心舍弃梦想。到现在，我依然不知道怎样才能做到这一点。打个比方，这就如同单相思的感觉，明知恋情不会有结果，却还是忘不了对方。\r\n\r\n> 我的回答之所以发挥了作用，原因不是别的，是因为他们自己很努力。如果自己不想积极认真地生活，不管得到什么样的回答都没用。\r\n\r\n> 无论现在多么的不开心，你要相信，明天会比今天更好。\r\n\r\n> 人与人之间情断义绝，并不需要什么具体理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<!-- end -->\r\n"},{"type":"file","name":"js中的浅复制和深复制.md","title":"'js中的浅复制和深复制'","timestamp":1509009078000,"date":"2017-10-26 17:11:18","tags":"js,深复制,浅复制","content":"\n<!-- deleteAbove -->\n\n在很多情况下，我们需要在不影响原数组的情况下 操作数组，这时候就需要对目标数组进行复制，下面看看 js 中复制的两种形式。\n\n\n<!--more-->\n\n\n### js中的浅复制和深复制\n\n\n#### 浅？深？\n\n这个深浅 ，应该就是字面上的意思 ，复制的深浅。\n\n加入一个数组 有多层，浅复制的话 ，只是复制了这个 数组的第一层 ，数组里面的 还是指向原来数组里面对应的，修改了一个，两个数组都会改变\n\n```js\nvar one = [\n            [1,2,3],\n            [4,5,6],\n            [7,8,9]\n          ]\nvar two = one.slice();\n/** two\n [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n**/\n\ntwo[0][0] = 111;\n\n/** one two\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n这种影响只限于 修改原来数组已有的 部分 如果向 two里面新加一个，则不会影响one\n\n**/\n\ntwo.push([1,1,1])\n\n/** one ：\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n   two :\n    [\n        [111,2,3],\n        [4,5,6],\n        [7,8,9],\n        [1,1,1]\n    ]\n\n**/\n```\n\n类似的还有对象。\n\n> 深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。\n\n为了避免这种现象 ，就需要使用 深复制，它能避免出现这种修改原数组的现象。\n\n接下来 看看 两种复制方式 的具体实现方法。\n\n\n#### 浅复制\n\n- **1-直接用 = **：\n\n这种方法只使用与 字符串 或者数字的复制，数组或对象使用 = 是复制的引用，指向的还是同一个东西的。\n\n- **2-数组**\n    - slice()\n    - var b = [...a]; // 解构赋值\n    - Array.from //  ES6 新增的 Array 方法\n    - concat()\n\n这种方法 适用于一阶数组 。二阶以上就不管用了。\n\n- **3-对象**\n\n使用一层循环 把 目标对象里面的属性全都复制到一个新的对象里面去\n\n```js\nvar res = {};\nfor(var key in object){\n    res[key] = object[key];\n}\n```\n但是这只适用 于 一层 如果对象里面的某个属性的值 还是对象 ，那就不适用了。\n\n\n#### 深复制\n\n深复制的情况一般见于 多阶数组或者多阶对象。\n\n无论是数组还是对象，都需要用循环和递归 来讲其中的每一个属性值 复制到另一个 数组或对象里面。\n\n下面这个方法可以深复制 数组或对象：\n\n```js\nvar cloneObj = function(obj){\n    var str, newobj = obj.constructor === Array ? [] : {};\n    if(typeof obj !== 'object'){\n        return;\n    } else if(window.JSON){\n        str = JSON.stringify(obj), //系列化对象\n        newobj = JSON.parse(str); //还原\n    } else {\n        for(var i in obj){\n            newobj[i] = typeof obj[i] === 'object' ?\n            cloneObj(obj[i]) : obj[i];\n        }\n    }\n    return newobj;\n};\n\n\n//  来源 https://www.zhihu.com/question/23031215\n```\n\n**还有一个特别的技巧**：\n\n\n那就是 把对象转字符串在转对象：\n```js\nvar a =[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n];\n\nvar b =  JSON.parse(JSON.stringify(a));\n\nb[0][0] = 111;\n/*\n a :   [\n        [1,2,3],\n        [4,5,6],\n        [7,8,9]\n       ]\n\n b : [\n      [111,2,3],\n      [4,5,6],\n      [7,8,9]\n     ]\n\n*/\n\n```\n\n#### 总结\n1. 字符串 ，数字的 复制 用 = 就可以了\n2. 一维数组 用 slice 、concat 、[...] 或者 Array.from 都可以\n3. 多维数组 或 对象 普遍用神技  ```JSON.parse(JSON.stringify());```\n   of course 如果你不嫌麻烦的话 可以写一个递归的方法来深复制。\n\n\n> 2017/10/26 下午5:13:01 哞\n","categories":"未分类"},{"type":"file","name":"虚拟节点VNode.md","title":"虚拟节点VNode","timestamp":1507620300000,"date":"2017-10-10 15:25","tags":"vue,VNode,虚拟节点,问题","content":"\r\n<!-- deleteAbove -->\r\n\r\n\r\nVirtual DOM （虚拟树） 大幅减少了DOM操作带来的重计算步骤。\r\n<!--more-->\r\n通过将对真是dom的操作，现在虚拟dom上操作完 再将最后的结果 替换到真是dom上去 极大提升了效率，减少了开销。\r\n\r\n\r\n## VNode\r\n\r\n### VNode基类\r\n一个VNode 对象其实和真是的dom对象很类似的，但是却比原生的Dom节点元素少了很多不必要的属性，这也是操作 VNode 比 操作真是dom元素 更快的原因之一，因为真是dom节点的属性多，遍历一次所需的时间也更多 ，然而在实际dom修改中，大部分的属性都是不需要的。\r\n\r\nVNode 定义好之后，将会通过createElement方法 将其渲染成dom节点。\r\n\r\n展示部分VNode的源码，\r\n\r\n完整的源码在 [这里](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js)\r\n\r\n对于VNode的各个属性的解释看 [这里](https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown)\r\n\r\n\r\n```js\r\nexport default class VNode {\r\n  tag: string | void;\r\n  data: VNodeData | void;\r\n  children: ?Array<VNode>;\r\n  text: string | void;\r\n  //......\r\n\r\n  // 构造函数\r\n  constructor (\r\n    tag?: string,\r\n    data?: VNodeData,\r\n    children?: ?Array<VNode>,\r\n    text?: string,\r\n    elm?: Node,\r\n    context?: Component,\r\n    componentOptions?: VNodeComponentOptions,\r\n    asyncFactory?: Function\r\n  ) {\r\n  // 初始化\r\n    this.tag = tag\r\n    this.data = data\r\n    this.children = children\r\n    // ......\r\n  }\r\n\r\n  // DEPRECATED: alias for componentInstance for backwards compat.\r\n  /* istanbul ignore next */\r\n  get child (): Component | void {\r\n    return this.componentInstance\r\n  }\r\n}\r\n```\r\n\r\n可以看出 VNode其实就是一个存着 **定义一个dom元素需要的各种属性** 的 *对象*\r\n\r\n举个例子：\r\n```js\r\n{\r\n    tag: 'div'\r\n    data: {\r\n        class: 'test'\r\n    },\r\n    children: [\r\n        {\r\n            tag: 'a',\r\n            data: {\r\n                class: 'demo',\r\n                href: '#'\r\n            }\r\n            text: 'click me'\r\n        }\r\n    ]\r\n}\r\n```\r\n调用 createElement() 之后，渲染的结果将会是 ：\r\n```html\r\n<div class=\"test\">\r\n    <a class=\"demo\" href=\"#\">click me</a>\r\n</div>\r\n\r\n```\r\n\r\n### VNode 的方法\r\n\r\n接下来在看看 VNode的其他方法 ：\r\n\r\n```js\r\n// 创建一个空 VNode对象\r\nexport const createEmptyVNode = (text: string = '') => {\r\n  const node = new VNode()\r\n  node.text = text\r\n  node.isComment = true\r\n  return node\r\n}\r\n\r\n// 创建一个 文本对象\r\nexport function createTextVNode (val: string | number) {\r\n  return new VNode(undefined, undefined, undefined, String(val))\r\n}\r\n\r\n\r\n// 复制一个VNode对象\r\nexport function cloneVNode (vnode: VNode, deep?: boolean): VNode {\r\n  const cloned = new VNode(\r\n    vnode.tag,\r\n    vnode.data,\r\n    vnode.children,\r\n    vnode.text,\r\n    vnode.elm,\r\n    vnode.context,\r\n    vnode.componentOptions,\r\n    vnode.asyncFactory\r\n  )\r\n  cloned.ns = vnode.ns\r\n  cloned.isStatic = vnode.isStatic\r\n  cloned.key = vnode.key\r\n  cloned.isComment = vnode.isComment\r\n  cloned.isCloned = true\r\n  if (deep && vnode.children) {\r\n    cloned.children = cloneVNodes(vnode.children)\r\n  }\r\n  return cloned\r\n}\r\n// 批量复制 VNode 本质是 循环调用  cloneVNode 方法\r\nexport function cloneVNodes (vnodes: Array<VNode>, deep?: boolean): Array<VNode> {\r\n  const len = vnodes.length\r\n  const res = new Array(len)\r\n  for (let i = 0; i < len; i++) {\r\n    res[i] = cloneVNode(vnodes[i], deep)\r\n  }\r\n  return res\r\n}\r\n\r\n```\r\n以上 是 VNode  的源码内容 很好理解\r\n\r\n但是。。。\r\n\r\n**多次提到 createElement()方法 好像并没有呀。。。**\r\n\r\n\r\n其实  createElement 和 createComponent 已经被单独拿出来了 [链接](https://github.com/vuejs/vue/tree/dev/src/core/vdom)\r\n\r\n\r\n> 问题\r\n\r\n- 关于createElement ,createComponent 这两个方法还需要仔细的理解.\r\n- 对于VNode的一些常用到的属性可以稍微熟悉一下\r\n\r\n\r\n参考文章：\r\n\r\n- [VNode节点-github](https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown)\r\n- [对 virtual-dom 的一些理解](https://zhuanlan.zhihu.com/p/25630842)\r\n","categories":"未分类"},{"type":"file","name":"输入url之后发生了什么.md","title":"输入url之后发生了什么","timestamp":1506587100000,"date":"2017-09-28 16:25","tags":"HTTP,url","content":"\r\n<!-- deleteAbove -->\r\n**[转]**  这是关于http的一些基础知识，了解这些知识还是很有必要的。\r\n\r\n<!-- more -->\r\n\r\n### 输入 URL 后发生了什么\r\n\r\n\r\n#### 1.生成 HTTP 请求消息\r\n\r\n浏览器会用 HTTP 协议生成请求消息去 web服务器请求资源，\r\n\r\n消息格式包括 请求行，请求头和请求体；\r\n\r\n对应的响应也有： 状态行 消息头 消息体\r\n\r\n这些在浏览器的network都能看到。\r\n\r\n#### 2.DNS\r\n\r\nDNS ： 域名服务系统  domain name systerm\r\n可以将域名 转换成ip地址。\r\n\r\n\r\n#### 3.建立连接--三次握手\r\n\r\n有了IP地址了，就要与服务器建立连接了（  但是链接服务器的工作不是浏览器来做的 而是委托操作系统的协议栈发送信息）。 用到的是  **TCP 协议**\r\n\r\n\r\n#### 4.网页请求与显示\r\n建立连接之后  ，客户端就可以开始进行各种请求了\r\n\r\n#### 5.断开连接--四次挥手\r\n\r\n- 主机向服务器发送一个断开连接的请求（不早了，我该走了）；\r\n\r\n- 服务器接到请求后发送确认收到请求的信号（知道了）；\r\n\r\n- 服务器向主机发送断开通知（我也该走了）；\r\n\r\n- 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；\r\n\r\n\r\n> 转自 [前端解忧杂货铺](https://zhuanlan.zhihu.com/p/23155051)\r\n\r\n> 更详细的内容进这个[传送阵](https://zhuanlan.zhihu.com/p/28946087)\r\n","categories":"未分类"},{"type":"file","name":"js中不同数据类型的加法.md","title":"js中不同数据类型的加法","timestamp":1506503700000,"date":"2017-09-27 17:15","tags":"js,数据类型","content":"\r\n<!-- deleteAbove -->\r\n--------\r\n\r\n### 前言\r\n在js 中 有5中基础类型 undefined null boolean number string  和一种引用类型 object\r\n\r\n不同类型之间的加法是怎么进行的呢 ？\r\n\r\n<!-- more -->\r\nex:  a+b\r\n\r\n### 步骤\r\n1. 首先对加号两边的 a,b 进行  ToPrimitive()操作  转换成原始值 也就是 专门对于object的。如果是个原始值（基础类型）,直接返回，如是 object,\r\n**先尝试valueOf()方法 ，如果返回的是原始值，就返回 ；如果不是，继续使用toString(),如果是原始值就返回 ，再不是就抛错(一般不会出现)**\r\n\r\n也就是 ：  valueOf  >  toString  >  error\r\n\r\n\r\n2. 接下来 等号两边都是原始值了，先看看有没有string类型的 如果有 那就把另一个也弄成string 然后字符串拼接\r\n\r\n3. 如果都不是，就转成数字number类型 再相加\r\n\r\n\r\n\r\n\r\n> 附表\r\n\r\n各类型转 string\r\n\r\n参数  | 结果\r\n---|---\r\nundefined  |\t\"undefined\"\r\nnull  |\t\"null\"\r\n布尔值 |\t\"true\"  或者 \"false\"\r\n数字   |\t数字作为字符串,比如. \"1.765\"\r\n字符串  |\t无需转换\r\n\r\n\r\n\r\n各类型转 number\r\n\r\n参数    |\t结果\r\n---|---\r\nundefined   |\tNaN\r\nnull    |\t+0\r\n布尔值  |\ttrue被转换为1,false转换为+0\r\n数字    |\t无需转换\r\n字符串  |\t由字符串解析为数字.例如,\"324\"被转换为324\r\n\r\n\r\n数组 和 对象的 valueOf\r\n\r\n参数    |\t结果\r\n---|---\r\n[1,2,3]   |\t[1,2,3]\r\n{a:\"a\"}    |\t{a:\"a\"}\r\n\r\n> 都会返回原值 除非，手动修改了对象的 valueOf 属性\r\n\r\n数组 和 对象的 toString()\r\n参数    |\t结果\r\n---|---\r\n[1,2,3]   |\t'1,2,3'\r\n{a:\"a\"}    | \"[object Object]\"\r\n\r\n> 对象都会返回\"[object Object]\"，包括空对象 {} ，  除非手动修改了对象的 valueOf 属性\r\n\r\n\r\n\r\n### 题目\r\n> 思考\r\n\r\n```js\r\n\r\n[]+[]\r\n\r\n{}+{}  \r\n\r\n{}+[]\r\n\r\n[]+{}\r\n\r\n({}+{})\r\n\r\n```\r\n### 另外\r\n\r\n简单类型都放在栈（stack）里\r\n对象类型都放在堆（heap）里\r\n不同的对象是不等的所以有：\r\n```js\r\n[]==[]   // false\r\n\r\n```\r\n参考文章：\r\n- [https://github.com/jawil/blog/issues/1]\r\n","categories":"未分类"}]