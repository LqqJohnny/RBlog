[{"type":"file","name":"js中的浅复制和深复制.md","title":"js中的浅复制和深复制","timestamp":1509009078000,"date":"2017-10-26 17:11:18","tags":"js,深复制,浅复制","categories":"hexo","content":"\n<!-- deleteAbove -->\n\n在很多情况下，我们需要在不影响原数组的情况下 操作数组，这时候就需要对目标数组进行复制，下面看看 js 中复制的两种形式。\n\n\n<!--more-->\n\n\n### js中的浅复制和深复制\n\n\n#### 浅？深？\n\n这个深浅 ，应该就是字面上的意思 ，复制的深浅。\n\n加入一个数组 有多层，浅复制的话 ，只是复制了这个 数组的第一层 ，数组里面的 还是指向原来数组里面对应的，修改了一个，两个数组都会改变\n\n```js\nvar one = [\n            [1,2,3],\n            [4,5,6],\n            [7,8,9]\n          ]\nvar two = one.slice();\n/** two\n [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n**/\n\ntwo[0][0] = 111;\n\n/** one two\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n这种影响只限于 修改原来数组已有的 部分 如果向 two里面新加一个，则不会影响one\n\n**/\n\ntwo.push([1,1,1])\n\n/** one ：\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n   two :\n    [\n        [111,2,3],\n        [4,5,6],\n        [7,8,9],\n        [1,1,1]\n    ]\n\n**/\n```\n\n类似的还有对象。\n\n> 深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。\n\n为了避免这种现象 ，就需要使用 深复制，它能避免出现这种修改原数组的现象。\n\n接下来 看看 两种复制方式 的具体实现方法。\n\n\n#### 浅复制\n\n- **1-直接用 = **：\n\n这种方法只使用与 字符串 或者数字的复制，数组或对象使用 = 是复制的引用，指向的还是同一个东西的。\n\n- **2-数组**\n    - slice()\n    - var b = [...a]; // 解构赋值\n    - Array.from //  ES6 新增的 Array 方法\n    - concat()\n\n这种方法 适用于一阶数组 。二阶以上就不管用了。\n\n- **3-对象**\n\n使用一层循环 把 目标对象里面的属性全都复制到一个新的对象里面去\n\n```js\nvar res = {};\nfor(var key in object){\n    res[key] = object[key];\n}\n```\n但是这只适用 于 一层 如果对象里面的某个属性的值 还是对象 ，那就不适用了。\n\n\n#### 深复制\n\n深复制的情况一般见于 多阶数组或者多阶对象。\n\n无论是数组还是对象，都需要用循环和递归 来讲其中的每一个属性值 复制到另一个 数组或对象里面。\n\n下面这个方法可以深复制 数组或对象：\n\n```js\nvar cloneObj = function(obj){\n    var str, newobj = obj.constructor === Array ? [] : {};\n    if(typeof obj !== 'object'){\n        return;\n    } else if(window.JSON){\n        str = JSON.stringify(obj), //系列化对象\n        newobj = JSON.parse(str); //还原\n    } else {\n        for(var i in obj){\n            newobj[i] = typeof obj[i] === 'object' ?\n            cloneObj(obj[i]) : obj[i];\n        }\n    }\n    return newobj;\n};\n\n\n//  来源 https://www.zhihu.com/question/23031215\n```\n\n**还有一个特别的技巧**：\n\n\n那就是 把对象转字符串在转对象：\n```js\nvar a =[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n];\n\nvar b =  JSON.parse(JSON.stringify(a));\n\nb[0][0] = 111;\n/*\n a :   [\n        [1,2,3],\n        [4,5,6],\n        [7,8,9]\n       ]\n\n b : [\n      [111,2,3],\n      [4,5,6],\n      [7,8,9]\n     ]\n\n*/\n\n```\n\n#### 总结\n1. 字符串 ，数字的 复制 用 = 就可以了\n2. 一维数组 用 slice 、concat 、[...] 或者 Array.from 都可以\n3. 多维数组 或 对象 普遍用神技  ```JSON.parse(JSON.stringify());```\n   of course 如果你不嫌麻烦的话 可以写一个递归的方法来深复制。\n\n\n> 2017/10/26 下午5:13:01 哞\n"},{"type":"file","name":"text.md","title":"text","timestamp":1509009078000,"date":"2017-10-26 17:11:18","tags":"js,深复制,浅复制","categories":"hexo","content":"\r\n\r\n## hello\r\n"},{"type":"file","name":"js中不同数据类型的加法.md","title":"js中不同数据类型的加法","timestamp":1506503700000,"date":"2017-09-27 17:15","tags":"js,数据类型","categories":"kk","content":"\r\n\r\n### 前言\r\n在js 中 有5中基础类型 undefined null boolean number string  和一种引用类型 object\r\n\r\n不同类型之间的加法是怎么进行的呢 ？\r\n\r\n<!-- more -->\r\nex:  a+b\r\n\r\n### 步骤\r\n1. 首先对加号两边的 a,b 进行  ToPrimitive()操作  转换成原始值 也就是 专门对于object的。如果是个原始值（基础类型）,直接返回，如是 object,\r\n**先尝试valueOf()方法 ，如果返回的是原始值，就返回 ；如果不是，继续使用toString(),如果是原始值就返回 ，再不是就抛错(一般不会出现)**\r\n\r\n也就是 ：  valueOf  >  toString  >  error\r\n\r\n\r\n2. 接下来 等号两边都是原始值了，先看看有没有string类型的 如果有 那就把另一个也弄成string 然后字符串拼接\r\n\r\n3. 如果都不是，就转成数字number类型 再相加\r\n\r\n\r\n\r\n\r\n> 附表\r\n\r\n各类型转 string\r\n\r\n参数  | 结果\r\n---|---\r\nundefined  |\t\"undefined\"\r\nnull  |\t\"null\"\r\n布尔值 |\t\"true\"  或者 \"false\"\r\n数字   |\t数字作为字符串,比如. \"1.765\"\r\n字符串  |\t无需转换\r\n\r\n\r\n\r\n各类型转 number\r\n\r\n参数    |\t结果\r\n---|---\r\nundefined   |\tNaN\r\nnull    |\t+0\r\n布尔值  |\ttrue被转换为1,false转换为+0\r\n数字    |\t无需转换\r\n字符串  |\t由字符串解析为数字.例如,\"324\"被转换为324\r\n\r\n\r\n数组 和 对象的 valueOf\r\n\r\n参数    |\t结果\r\n---|---\r\n[1,2,3]   |\t[1,2,3]\r\n{a:\"a\"}    |\t{a:\"a\"}\r\n\r\n> 都会返回原值 除非，手动修改了对象的 valueOf 属性\r\n\r\n数组 和 对象的 toString()\r\n参数    |\t结果\r\n---|---\r\n[1,2,3]   |\t'1,2,3'\r\n{a:\"a\"}    | \"[object Object]\"\r\n\r\n> 对象都会返回\"[object Object]\"，包括空对象 {} ，  除非手动修改了对象的 valueOf 属性\r\n\r\n\r\n\r\n### 题目\r\n> 思考\r\n\r\n```js\r\n\r\n[]+[]\r\n\r\n{}+{}  \r\n\r\n{}+[]\r\n\r\n[]+{}\r\n\r\n({}+{})\r\n\r\n```\r\n### 另外\r\n\r\n简单类型都放在栈（stack）里\r\n对象类型都放在堆（heap）里\r\n不同的对象是不等的所以有：\r\n```js\r\n[]==[]   // false\r\n\r\n```\r\n参考文章：\r\n- [https://github.com/jawil/blog/issues/1]\r\n"}]